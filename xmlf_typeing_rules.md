# eMLF typing rules (extracted from `papers/these-finale-english.txt`)

This note summarizes the thesis’ definition of *typing* for **eMLF** (the “explicit” flavour of MLF) in the **graphic-constraint** presentation. It is not a new formalization: it is a cleaned-up extraction of the relevant definitions/rules that are spread across the thesis.

Terminology note: the thesis mostly uses **eMLF** for the *graphic* system induced by the instance relation `⊑≈`. In §15.6, “eMLF” refers instead to the separate *syntactic* presentation by Le Botlan & Rémy (2007); this file is about the thesis’ graphic/constraint account.

Primary anchors in `papers/these-finale-english.txt`:
- §9.4 + Figure 9.4.1 (typing constraints / translation of λ-terms to constraints)
- §10.5.2 (which instance relation defines gMLF vs eMLF vs iMLF)
- §5.3.4 (similarity `≈` and instance-modulo-similarity `⊑≈`)
- §12.3.2 + Figure 12.3.1 + Definition 12.3.3 (type annotations via coercion functions)

---

## 1. What “eMLF” means in the thesis

The thesis defines three “flavours of MLF” by *which instance relation* is used to interpret (typing) constraints:

| System | Instance relation |
|---|---|
| **gMLF** | `⊑` |
| **eMLF** | `⊑≈` (instance modulo similarity) |
| **iMLF** | `⊑−` (instance modulo abstraction) |

So, compared to gMLF, **eMLF changes the metatheory of “being an instance”** by quotienting out *similarity*.

### 1.1 Similarity (≈) and instance-modulo-similarity (⊑≈)

The thesis defines a *reversible* subrelation of instance:

- `⊑rmw` (“reversible instance”) is the subrelation of `⊑` generated by **Merge**, **Raise**, and **Weaken** *restricted to monomorphic nodes*.

Using that:

- Similarity `≈` is the equivalence relation generated by reversible steps in either direction: `(⊑rmw ∪ ⊒rmw)*`.
- Instance modulo similarity `⊑≈` is the closure of “ordinary instance” plus similarity: `(⊑ ∪ ≈)*`.

Intuition (as used throughout the thesis): **types are read modulo similarity**, i.e. monomorphic sharing/binding differences are not semantically essential, and eMLF is the system that bakes this into the notion of instance.

---

## 2. Expression language + type annotations (for eMLF programs)

### 2.1 Core expressions

The thesis starts from the untyped λ-calculus with let:

```
a ::= x | λ(x) a | a a | let x = a in a
```

Typing is defined *via constraint generation* (next section), not by a direct syntax-directed `Γ ⊢ a : τ` judgment.

### 2.2 Type annotations are encoded using coercion functions

Rather than adding dedicated typing rules for annotated expressions, the thesis encodes annotations by adding a denumerable family of constants (“coercion/retyping functions”) to the initial environment.

For each closed type `τ` there is a constant `cτ`, and:

- `(a : τ)` is syntactic sugar for `cτ a`.
- `λ(x : τ) a` is syntactic sugar for `λ(x) let x = (x : τ) in a`.

The thesis also generalizes “`τ`” to richer **annotation graphs** `κ` (with both existential and universal parts); each `κ` yields a coercion function `cκ` whose type is designed so that:
- the **domain** forces the annotated type (rigidly bound polymorphism is *required*), and
- the **codomain** can still be instantiated (flexibly bound polymorphism is *provided*),
while existential parts are shared so they are instantiated consistently on both sides.

### 2.3 Initial typing environment for annotations

Definition 12.3.3: the thesis’ initial typing environment (for MLF, hence for eMLF) contains **all coercion functions** `cκ` for all annotations `κ`.

---

## 3. “Typing rules” as constraint generation rules (Figure 9.4.1)

### 3.1 Judgment form used in the thesis

The thesis represents typing problems by translating expressions into **typing constraints** (a subclass of graphic constraints).

Key presentation choice (§9.4): generalization is allowed at *every* typing step, not only at `let`. Concretely, **each primitive expression is typed as a type scheme**, so the root of each basic constraint fragment is a **gen node** (`G`).

The four primitive constructs are translated by the rules of Figure 9.4.1, summarized below.

### 3.2 Rules

#### VAR (variable)

A variable occurrence `x` is typed using the universal type scheme `∀(α) α`, represented graphically as:
- a fresh gen node `g`, with one child node `⊥` bound on `g`.

The occurrence is connected to the surrounding typing environment by the unique constraint edge labeled `x`. If there is no such edge, the resulting constraint is not closed, hence untypable (in the sense of the thesis’ constraint semantics).

#### LET (let-binding)

`let x = a1 in a2` is typed “like `a2`”, with the additional constraint that **all occurrences of `x` in `a2` must be instances of `a1`**.

In the constraint picture, this is enforced by instantiation edges linking `a1`’s type scheme to the use sites of `x` inside `a2`.

#### ABS (λ-abstraction)

`λ(x) a` is typed as the type scheme:

```
∀(α ⩾ ⊥) ∀(β ⩾ ⊥) α → β
```

and the graph enforces:
- the type of each occurrence of `x` in the body `a` must **unify** with the domain `α`;
- the codomain `β` must be an **instance** of the type of the body `a`.

#### APP (application)

For `a1 a2`, the translation introduces an arrow type existentially and returns its codomain:
- the domain of the arrow is constrained to be an **instance** of the type of `a2`;
- the arrow type itself is constrained to be an **instance** of the type of `a1`.

Equivalently: the function position must have a type scheme that can be instantiated to an arrow whose argument type can be instantiated to fit the argument.

---

## 4. What “typable in eMLF” amounts to (in this framework)

For an expression `a` (including the desugaring of annotations into coercion constants), build its typing constraint `χ(a)` by the rules above. Then:

- `a` is typable in **eMLF** iff `χ(a)` has a solution under the **eMLF instance relation** `⊑≈` (instance modulo similarity).

The type(s) assigned to `a` are read from the expansion of the root scheme in a solution/presolution, as defined by the thesis’ constraint semantics.
