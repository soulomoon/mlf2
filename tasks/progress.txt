# Ralph Progress Log

## Project: MLF Monad Stack Simplification
## Branch: ralph/monad-stack-simplification
## Started: 2026-02-01

---

## Codebase Patterns

- **Module Import Cycles**: Ops.hs imports Base.hs, so Base cannot import Ops. Implement typeclass methods directly in Base.hs using local definitions.
- **Typeclass Method Naming**: When adding methods to MonadPresolution that conflict with Ops functions, remove imports from Ops in consuming modules and use the typeclass methods directly.
- **Lift Removal**: After adding methods to MonadPresolution, remove `lift $` calls before those methods in EdgeUnifyM since they now come from the typeclass instance.

---

## 2026-02-01 - US-001
- Extended MonadPresolution typeclass with getNode and getCanonicalNode operations
- Implemented methods in PresolutionM instance using local findRoot and node lookup
- Implemented methods in EdgeUnifyM instance via liftPresolution
- Removed getNode and getCanonicalNode imports from Ops in EdgeUnify.hs
- Removed `lift $` calls before getNode/getCanonicalNode in EdgeUnify.hs (5 occurrences)
- Removed getNode and getCanonicalNode imports from Ops in EdgeProcessing.hs
- All tests pass

**Files changed:**
- src/MLF/Constraint/Presolution/Base.hs: Added getNode and getCanonicalNode to MonadPresolution typeclass, implemented findRoot and instance methods
- src/MLF/Constraint/Presolution/EdgeUnify.hs: Removed Ops imports, removed lift $ calls
- src/MLF/Constraint/Presolution/EdgeProcessing.hs: Removed Ops imports

**Learnings for future iterations:**
- When adding typeclass methods that conflict with existing functions in other modules, need to remove imports from those modules
- The Ops module imports Base, so Base cannot import Ops - must implement methods directly
- EdgeUnifyM already has MonadPresolution instance, so just need to add the new methods to the instance
- Removing `lift $` calls is straightforward once the typeclass methods are available
---

## 2026-02-01 - US-003
- Extended MonadPresolution typeclass with lookupBindParent operation
- Implemented in PresolutionM using Binding.lookupBindParent from the constraint state
- Implemented in EdgeUnifyM via lift (typeclass method is now available)
- All tests pass

**Files changed:**
- src/MLF/Constraint/Presolution/Base.hs: Added lookupBindParent to MonadPresolution typeclass, implemented in PresolutionM instance
- src/MLF/Constraint/Presolution/EdgeUnify.hs: Added lookupBindParent to MonadPresolution EdgeUnifyM instance

**Learnings for future iterations:**
- lookupBindParent takes NodeRef (not NodeId) to match Binding.lookupBindParent signature
- For type nodes, use `lookupBindParent (typeRef nid)` to convert NodeId to NodeRef
- The pattern is consistent: add to typeclass in Base.hs, implement in PresolutionM, add to EdgeUnifyM via lift
---

## 2026-02-01 - US-004
- Extended MonadPresolution typeclass with modifyPresolution operation
- Implemented in PresolutionM using modify' on psPresolution field
- Implemented in EdgeUnifyM via lift (typeclass method is now available)
- All tests pass

**Files changed:**
- src/MLF/Constraint/Presolution/Base.hs: Added modifyPresolution to MonadPresolution typeclass, implemented in PresolutionM instance
- src/MLF/Constraint/Presolution/EdgeUnify.hs: Added modifyPresolution to MonadPresolution EdgeUnifyM instance

**Learnings for future iterations:**
- modifyPresolution follows the same pattern as modifyConstraint but operates on psPresolution field instead of psConstraint
- The implementation is straightforward: `modify' $ \st -> st { psPresolution = f (psPresolution st) }`
---

## 2026-02-01 - US-005
- Extended MonadPresolution typeclass with getConstraintAndCanonical operation
- Extended MonadEdgeUnify typeclass with isBoundAboveInBindingTreeM and queuePendingWeakenM operations
- Replaced liftPresolution $ getConstraintAndCanonical with direct getConstraintAndCanonical call
- Replaced liftPresolution $ isBoundAboveInBindingTree with isBoundAboveInBindingTreeM
- Replaced liftPresolution $ queuePendingWeaken with queuePendingWeakenM
- Replaced unifyAcyclicRawWithRaiseTracePrefer with unifyAcyclicRawWithRaiseTracePreferM
- Removed getConstraintAndCanonical import from StateAccess in EdgeUnify.hs and EdgeProcessing.hs
- Fixed findRoot to findRootM in unifyAcyclicEdge
- All tests pass

**Files changed:**
- src/MLF/Constraint/Presolution/Base.hs: Added getConstraintAndCanonical to MonadPresolution typeclass
- src/MLF/Constraint/Presolution/EdgeUnify.hs: Added MonadEdgeUnify methods, replaced liftPresolution calls
- src/MLF/Constraint/Presolution/EdgeProcessing.hs: Removed getConstraintAndCanonical import from StateAccess

**Learnings for future iterations:**
- When adding typeclass methods that conflict with existing imports, remove the conflicting imports
- The pattern for adding EdgeUnifyM-specific operations: add to MonadEdgeUnify typeclass, implement via liftPresolution in instance
- For functions that work in PresolutionM but are called from EdgeUnifyM, add them to MonadEdgeUnify typeclass
- Check for all modules that import conflicting functions when making typeclass changes
---

## 2026-02-01 - US-006
- Added MonadSolve typeclass to Solve.hs with getConstraint, modifyConstraint, getUnionFind, throwSolveError
- Created instance for the concrete SolveM monad
- Exported MonadSolve(..) and SolveM from the module
- Enabled FlexibleInstances language extension
- All tests pass

**Files changed:**
- src/MLF/Constraint/Solve.hs: Added MonadSolve typeclass and instance, updated exports

**Learnings for future iterations:**
- Follow the same pattern as MonadPresolution in Base.hs for consistency
- Need FlexibleInstances extension when creating instances for type synonyms like SolveM
- Import throwError from Control.Monad.Except for the throwSolveError implementation
- The typeclass methods should mirror the existing internal helper functions (lookupNode, findRoot, etc.)
---

## 2026-02-01 - US-007
- Replaced all 12 `lift $ Left` calls with `throwSolveError` in Solve.hs
- Error calls updated in:
  - ForallArityMismatch (processEdge TyForall case)
  - BindingTreeError (two occurrences in orderedBinders calls)
  - UnexpectedExpNode (two occurrences for TyExp nodes)
  - BaseClash (decomposeUnifyChildren mismatch)
  - ConstructorClash (decomposeUnifyChildren failure)
  - MissingNode (lookupNode failure)
  - OccursCheckFailed (three occurrences in occursCheck)
  - BindingTreeError (harmonize failure)
- Reduced lift $ count from 12 to 0 (target was under 4)
- All tests pass

**Files changed:**
- src/MLF/Constraint/Solve.hs: Replaced all lift $ Left calls with throwSolveError

**Learnings for future iterations:**
- The MonadSolve typeclass from US-006 makes error throwing straightforward
- All error cases in Solve.hs now use the semantic `throwSolveError` instead of `lift $ Left`
- Pattern: once typeclass is defined, replacing lift calls is a simple search-and-replace operation
- No changes needed to imports since throwSolveError is defined in the same module
---
