## Codebase Patterns
- Validation command: cabal build all && cabal test
- Hspec test suite: mlf2-test
- Keep implementation paper-faithful to papers/these-finale-english.txt
- SrcType is a plain data type (not a GADT); avoid parameterizing it with type families as this breaks type inference at construction sites (e.g., `STForall "a" Nothing body` becomes ambiguous)
- Use separate data types (SrcType vs NormSrcType) rather than a single indexed GADT for staged frontend types — preserves backward compatibility
- Downstream modules import SrcType(..) from MLF.Frontend.Syntax or via MLF.API/MyLib re-exports
- Only `LambdaCase` is a default extension in mlf2.cabal; other extensions need per-file pragmas
- Adding a type parameter to a GADT is backward-compatible when existing type aliases fix the new parameter to the old concrete type (e.g., `type SurfaceExpr = Expr 'Surface SrcType`)

## Iteration Log
- 2026-02-08: Task initialized from PRD conversion.

## 2026-02-08 - US-001
- What was implemented: Staged frontend type kinds and constructors in Frontend.Syntax
  - Added `TypeStage` kind (`Raw | Normalized`)
  - Added `NormSrcType` data type with `NST*` constructors mirroring `SrcType`
  - Added `StructBound` data type (no variable constructor) for normalized forall bounds
  - Added `RawSrcType` alias for symmetry
  - Kept `SrcType` unchanged for full backward compatibility
- Files changed: src/MLF/Frontend/Syntax.hs
- **Learnings for future iterations:**
  - A GADT approach with `SrcTy (s :: TypeStage)` and `type family ForallBound s` was attempted first but abandoned: GHC cannot infer the stage parameter at construction sites when the type family makes `Nothing` ambiguous between `Maybe SrcType` and `Maybe StructBound`
  - The separate-data-type approach (SrcType + NormSrcType) is cleaner and requires zero downstream changes
  - `StructBound` excludes bare variables by construction (no `SBVar` constructor), satisfying the "unrepresentable at the type level" requirement
  - All 499 tests pass, no warnings
---

## 2026-02-08 - US-002
- What was implemented: Staged frontend expression types for raw and normalized annotations
  - Added type parameter `ty` to `Expr (s :: ExprStage) ty` GADT for annotation payloads
  - `ELamAnn`, `EAnn`, `ECoerceConst` now use `ty` instead of hardcoded `SrcType`
  - `deriving instance` constraints updated: `Eq ty =>` and `Show ty =>`
  - Backward-compatible aliases preserved: `SurfaceExpr = Expr 'Surface SrcType`, `CoreExpr = Expr 'Core SrcType`
  - New normalized aliases: `NormSurfaceExpr = Expr 'Surface NormSrcType`, `NormCoreExpr = Expr 'Core NormSrcType`
  - All exports added to module header with section comments
- Files changed: src/MLF/Frontend/Syntax.hs
- **Learnings for future iterations:**
  - Adding a type parameter to a GADT is backward-compatible when existing type aliases fix the new parameter to the old concrete type — zero downstream changes needed
  - The `Eq ty =>` and `Show ty =>` constraints on standalone deriving are required when the GADT stores `ty` values
  - Re-export chain (MLF.Frontend.Syntax → MLF.API via `module MLF.Frontend.Syntax` → MyLib) automatically picks up new exports
  - All 499 tests pass, no warnings
---