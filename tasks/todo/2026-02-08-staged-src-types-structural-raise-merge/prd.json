{
  "project": "mlf4",
  "branchName": "ralph/staged-src-types-structural-raise-merge",
  "description": "Introduce staged frontend SrcType/Expr normalization boundaries and refactor Merge/RaiseMerge gating to depend only on live structural graph facts.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Introduce staged frontend type kinds and constructors",
      "description": "As a compiler maintainer, I want staged frontend type constructors indexed by normalization state and top-variable policy so that normalized alias-bound forms are unrepresentable at the type level.",
      "acceptanceCriteria": [
        "Add staged frontend type definition (raw vs normalized, top-var policy) in Frontend.Syntax",
        "Export concrete aliases for raw and normalized frontend type forms",
        "Normalized bound form cannot encode top-level variable alias bounds by construction",
        "cabal build all succeeds",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Implemented as separate NormSrcType data type with StructBound (no variable constructor) rather than GADT with type family, to preserve full backward compatibility with existing SrcType usage."
    },
    {
      "id": "US-002",
      "title": "Stage frontend expression types for raw and normalized annotations",
      "description": "As a compiler maintainer, I want expression stages to carry raw vs normalized annotation payloads so phase ordering is enforced by types.",
      "acceptanceCriteria": [
        "Update Expr typing so annotation/coercion payloads track raw vs normalized stage",
        "Export raw and normalized surface/core expression aliases",
        "All modules compiling against Frontend.Syntax are updated for the new staged signatures",
        "cabal build all succeeds",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Added type parameter `ty` to Expr GADT for annotation type. SurfaceExpr/CoreExpr remain backward-compatible aliases (= Expr 'Surface SrcType / Expr 'Core SrcType). New NormSurfaceExpr/NormCoreExpr aliases use NormSrcType. Zero downstream changes needed."
    },
    {
      "id": "US-003",
      "title": "Add raw-to-normalized frontend normalization module",
      "description": "As a compiler maintainer, I want explicit normalization APIs that inline alias bounds capture-safely so normalized syntax can be the only input to constraint generation.",
      "acceptanceCriteria": [
        "Add Frontend.Normalize module with normalizeType and normalizeExpr (or equivalent)",
        "Normalization inlines alias bound forms like ∀(b ⩾ a) using capture-avoiding substitution",
        "Normalization keeps invalid self-bound cases deterministic via explicit error return",
        "Unit tests cover at least one alpha-capture avoidance scenario",
        "Typecheck passes",
        "Tests pass"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Added MLF.Frontend.Normalize module with normalizeType (SrcType → NormSrcType) and normalizeExpr (SurfaceExpr → NormSurfaceExpr). Alias bounds (∀(b ⩾ a). body) are inlined via capture-avoiding substitution. Self-bound foralls produce explicit SelfBoundVariable error. 27 new tests in FrontendNormalizeSpec covering free vars, substitution, normalization, and alpha-capture avoidance. All 526 tests pass."
    },
    {
      "id": "US-004",
      "title": "Split parser API into raw and normalized entrypoints",
      "description": "As an API consumer, I want to parse into raw AST or directly into normalized AST so tooling and compiler phases can use explicit boundaries.",
      "acceptanceCriteria": [
        "Expose raw parser entrypoints for eMLF types and expressions",
        "Expose normalized parser entrypoints that parse raw then normalize",
        "Parse error rendering remains available and usable for both paths",
        "Frontend parse specs are updated for raw and normalized APIs",
        "Typecheck passes",
        "Tests pass"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Added parseRawEmlfExpr/parseRawEmlfType (raw entrypoints returning SrcType/SurfaceExpr) and parseNormEmlfExpr/parseNormEmlfType (normalized entrypoints that parse raw then normalize, returning NormSrcType/NormSurfaceExpr). Added NormParseError sum type and renderNormParseError. Legacy parseEmlfExpr/parseEmlfType kept as aliases. All exports added to MLF.API. FrontendParseSpec updated with 17 new tests covering raw, normalized, legacy, and error rendering paths. All 543 tests pass."
    },
    {
      "id": "US-005",
      "title": "Make desugaring and Phase 1 normalized-input only",
      "description": "As a compiler maintainer, I want desugaring and constraint generation to only accept normalized surface syntax so alias elimination cannot be bypassed.",
      "acceptanceCriteria": [
        "Desugar entrypoint accepts normalized surface expressions only",
        "generateConstraints accepts normalized surface expressions only",
        "No implicit normalization occurs inside generateConstraints",
        "Constraint generation callsites are updated to normalize before Phase 1",
        "Typecheck passes",
        "Tests pass"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Changed desugarSurface to NormSurfaceExpr -> NormCoreExpr. Changed generateConstraints to accept NormSurfaceExpr. Converted internalizeCoercionType/Copy to work with NormSrcType (removed alias-bound special case, added structBoundToNormSrcType/structBoundFreeVars helpers). Updated pipeline (runPipelineElab*, runPipelineElabWith) and public API (inferConstraintGraph) signatures. All test callsites normalize via normalizeExpr before calling Phase 1. Self-bound forall test updated to check normalization error. All 543 tests pass."
    },
    {
      "id": "US-006",
      "title": "Update public API and pipeline to normalized-only contract",
      "description": "As an API consumer, I want public infer/elab entrypoints to require normalized expressions so phase boundaries are explicit and type-safe.",
      "acceptanceCriteria": [
        "Update public API exports to staged frontend types and normalized pipeline signatures",
        "runPipelineElab and runPipelineElabChecked (and config variants) accept normalized expressions",
        "inferConstraintGraph public signature matches normalized-only contract",
        "API and pipeline tests compile with staged signatures",
        "Typecheck passes",
        "Tests pass"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Updated MLF.Pipeline to export NormSurfaceExpr, NormSrcType(..), StructBound(..), NormalizationError(..), normalizeExpr, normalizeType alongside pipeline entrypoints. Updated MLF.API export list with section comments documenting staged types, normalization, constraint graph, elaboration types, pipeline configuration, and normalized-only pipeline entrypoints. Updated app/Main.hs to explicitly normalize via normalizeExpr before calling runPipelineElabWithConfig. All 543 tests pass."
    },
    {
      "id": "US-007",
      "title": "Remove alias-specific coercion internalization branch",
      "description": "As a compiler maintainer, I want coercion type internalization to rely on normalized input invariants instead of alias-shape special-cases.",
      "acceptanceCriteria": [
        "Remove or make unreachable alias-special branch in coercion type internalization for STForall alias bounds",
        "Retain necessary well-formedness checks unrelated to alias syntax survivability",
        "ConstraintGenSpec coverage reflects normalized-only alias handling",
        "Typecheck passes",
        "Tests pass"
      ],
      "priority": 7,
      "passes": true,
      "notes": "Alias-specific branch was already removed in US-005 when internalizeCoercionCopy switched from SrcType to NormSrcType (StructBound has no variable constructor). US-007 documents this invariant in Translate.hs, updates ConstraintGenSpec test descriptions to reflect normalized-only alias handling, and adds a new test verifying alias bounds are inlined by normalization before reaching constraint gen. ForallBoundMentionsBinder retained for structural self-reference (e.g., ∀(a ⩾ List a). a). All 544 tests pass."
    },
    {
      "id": "US-008",
      "title": "Drop precomputed binder-bound snapshots from edge-unify state",
      "description": "As a presolution maintainer, I want edge-unify state to avoid stale binder-bound metadata so witness gating always uses current graph truth.",
      "acceptanceCriteria": [
        "Remove eusBinderBounds from EdgeUnifyState",
        "Update initEdgeUnifyState signature and all callsites to remove binderBounds parameter",
        "Remove binderBounds map construction in EdgeProcessing.Unify",
        "Presolution modules compile after signature changes",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": true,
      "notes": "Removed eusBinderBounds field from EdgeUnifyState record. Updated initEdgeUnifyState signature to drop binderBounds parameter (3→2 args before interior/edgeRoot). Removed binderBounds map construction in EdgeProcessing.Unify (VarStore import also removed). shouldRecordRaiseMerge now uses lookupVarBoundM for live graph queries instead of precomputed snapshot. runEdgeUnifyForTest updated. All 544 tests pass."
    },
    {
      "id": "US-009",
      "title": "Refactor RaiseMerge gating to purely structural live queries",
      "description": "As a presolution maintainer, I want shouldRecordRaiseMerge to use canonical bounds, binding ancestry, and interior membership from the current constraint graph.",
      "acceptanceCriteria": [
        "shouldRecordRaiseMerge computes binder bound from current canonical graph state",
        "Decision logic uses only node kind, live bound root, edge-root ancestry, interior membership, and elimination state",
        "No-bound and same-root exclusions remain enforced",
        "Unbounded binders do not produce RaiseMerge",
        "Typecheck passes",
        "Tests pass"
      ],
      "priority": 9,
      "passes": true,
      "notes": "Refactored shouldRecordRaiseMerge to be the single source of truth for RaiseMerge gating. Moved elimination state check (isEliminated) into shouldRecordRaiseMerge so all five structural criteria (node kind, live bound root, same-root exclusion, edge-root ancestry/interior membership, elimination state) are encapsulated in one function. Removed redundant TyVar checks at call sites in unifyAcyclicEdge. Added comprehensive Haddock documenting the five-criterion decision logic. All queries use live canonical graph state — no precomputed snapshots. All 544 tests pass."
    },
    {
      "id": "US-010",
      "title": "Preserve witness normalization and translatability invariants",
      "description": "As a type-soundness maintainer, I want witness normalization/validation behavior to stay unchanged while gating source changes.",
      "acceptanceCriteria": [
        "Normalization of OpRaise followed by OpMerge to OpRaiseMerge remains intact",
        "Rigid endpoint translatability checks keep existing failure behavior",
        "Presolution witness canon/validation tests pass without loosening assertions",
        "Typecheck passes",
        "Tests pass"
      ],
      "priority": 10,
      "passes": true,
      "notes": "Validated that witness normalization and rigid-endpoint translatability invariants remain unchanged after structural RaiseMerge gating updates. Confirmed OpRaise;OpMerge -> OpRaiseMerge coalescing and rigid-endpoint failure behavior through focused specs, then ran full project validation (`cabal build all && cabal test`), with all 551 tests passing."
    },
    {
      "id": "US-011",
      "title": "Restore bounded aliasing baseline end-to-end",
      "description": "As a user of thesis-faithful elaboration, I want bounded aliasing examples to elaborate to ∀a. a -> a -> a in both checked and unchecked pipelines.",
      "acceptanceCriteria": [
        "ElaborationSpec bounded-alias baseline passes via runPipelineElab",
        "Same bounded-alias baseline passes via runPipelineElabChecked",
        "Result types are alpha-equivalent to ∀a. a -> a -> a",
        "Typecheck passes",
        "Tests pass"
      ],
      "priority": 11,
      "passes": true,
      "notes": "Updated edge-local merge recording to persist binder substitution targets before elimination and narrowed witness interior widening to multi-binder edges so required OpGraft evidence survives normalization without reintroducing non-binder translatability regressions. The bounded aliasing ElaborationSpec now asserts success for both runPipelineElab and runPipelineElabChecked; full validation (`cabal build all && cabal test`) passes (551 tests)."
    },
    {
      "id": "US-012",
      "title": "Update project docs and trackers for staged/structural model",
      "description": "As a maintainer, I want docs and bug tracking updated so staged frontend invariants and structural RaiseMerge gating are auditable.",
      "acceptanceCriteria": [
        "implementation_notes.md documents staged frontend raw->normalized boundary and structural RaiseMerge gating",
        "CHANGELOG.md includes concise entry for this feature",
        "Bugs.md updates bounded-alias bug status with linked regression tests",
        "TODO.md is updated if priorities changed",
        "Typecheck passes"
      ],
      "priority": 12,
      "passes": true,
      "notes": "Updated implementation_notes.md to record the staged raw->normalized frontend boundary and live structural RaiseMerge gating as implemented behavior (not pending direction). Added concise Unreleased changelog entries for staged syntax/normalized-only contracts and structural gating + bounded-alias restoration. Updated Bugs.md by moving BUG-2026-02-06-003 to Resolved with linked regression tests (ElaborationSpec bounded alias baseline + WitnessSpec invariants). TODO priorities were unchanged. Full validation gate `cabal build all && cabal test` passes (551 tests)."
    }
  ]
}
