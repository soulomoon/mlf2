{
  "project": "MLF Monad Stack Simplification",
  "branchName": "ralph/monad-stack-simplification",
  "description": "Reduce boilerplate from explicit lift calls by extending MTL typeclasses, introduce semantic newtypes, and expand test coverage",
  "userStories": [
    {
      "id": "US-001",
      "title": "Extend MonadPresolution with getNode operation",
      "description": "As a developer, I want getNode available in MonadPresolution so I don't need to lift node lookups.",
      "acceptanceCriteria": [
        "Add getNode :: NodeId -> m (Maybe TyNode) to MonadPresolution class in Base.hs",
        "Implement getNode in PresolutionM instance using NodeAccess.lookupNode",
        "Implement getNode in EdgeUnifyM instance via liftPresolution",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Implemented getNode and getCanonicalNode in MonadPresolution typeclass"
    },
    {
      "id": "US-002",
      "title": "Extend MonadPresolution with getCanonicalNode operation",
      "description": "As a developer, I want getCanonicalNode available in MonadPresolution so I don't need to lift canonical node lookups.",
      "acceptanceCriteria": [
        "Add getCanonicalNode :: NodeId -> m (Maybe TyNode) to MonadPresolution class",
        "Implement in PresolutionM: canonicalize then lookup",
        "Implement in EdgeUnifyM via liftPresolution",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Completed together with US-001"
    },
    {
      "id": "US-003",
      "title": "Extend MonadPresolution with lookupBindParent operation",
      "description": "As a developer, I want lookupBindParent available in MonadPresolution so I don't need to lift bind parent lookups.",
      "acceptanceCriteria": [
        "Add lookupBindParent :: NodeId -> m (Maybe (NodeRef, BindFlag)) to MonadPresolution class",
        "Implement in PresolutionM using Binding.lookupBindParent",
        "Implement in EdgeUnifyM via liftPresolution",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Implemented lookupBindParent for NodeRef (not NodeId) to match Binding.lookupBindParent signature"
    },
    {
      "id": "US-004",
      "title": "Extend MonadPresolution with modifyPresolution operation",
      "description": "As a developer, I want modifyPresolution available in MonadPresolution so I don't need to lift presolution state modifications.",
      "acceptanceCriteria": [
        "Add modifyPresolution :: (Presolution -> Presolution) -> m () to MonadPresolution class",
        "Implement in PresolutionM using modify on psPresolution field",
        "Implement in EdgeUnifyM via liftPresolution",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Implemented modifyPresolution following the same pattern as modifyConstraint"
    },
    {
      "id": "US-005",
      "title": "Replace lift calls in EdgeUnify.hs using new MonadPresolution ops",
      "description": "As a developer, I want EdgeUnify.hs to use typeclass methods instead of explicit lift calls.",
      "acceptanceCriteria": [
        "Replace lift $ getNode with getNode (using MonadPresolution)",
        "Replace lift $ getCanonicalNode with getCanonicalNode",
        "Replace lift $ lookupBindParent with lookupBindParent",
        "Reduce lift $ count in EdgeUnify.hs from 30 to under 15",
        "Typecheck passes",
        "All tests pass"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Added getConstraintAndCanonical to MonadPresolution, added isBoundAboveInBindingTreeM and queuePendingWeakenM to MonadEdgeUnify. Reduced liftPresolution $ calls from 3 to 0 in user code."
    },
    {
      "id": "US-006",
      "title": "Add MonadSolve typeclass to Solve.hs",
      "description": "As a developer, I want a MonadSolve typeclass so solve-phase operations don't require explicit lifting.",
      "acceptanceCriteria": [
        "Create MonadSolve typeclass with getConstraint, modifyConstraint, getUnionFind, throwSolveError",
        "Create instance for the concrete SolveM monad",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Implemented MonadSolve typeclass with all required methods. Exported MonadSolve(..) and SolveM from module."
    },
    {
      "id": "US-007",
      "title": "Replace lift calls in Solve.hs using MonadSolve",
      "description": "As a developer, I want Solve.hs to use MonadSolve methods instead of explicit lift calls.",
      "acceptanceCriteria": [
        "Replace lift $ throwError with throwSolveError",
        "Replace lift $ get/modify with MonadSolve methods",
        "Reduce lift $ count in Solve.hs from 12 to under 4",
        "Typecheck passes",
        "All tests pass"
      ],
      "priority": 7,
      "passes": true,
      "notes": "Replaced all 12 lift $ Left calls with throwSolveError. Reduced lift count to 0."
    },
    {
      "id": "US-008",
      "title": "Replace lift calls in Copy.hs, EdgeProcessing.hs, StateAccess.hs",
      "description": "As a developer, I want remaining presolution modules to use typeclass methods.",
      "acceptanceCriteria": [
        "Update Copy.hs to use MonadPresolution methods (4 lift calls)",
        "Update EdgeProcessing.hs to use MonadPresolution methods (1 lift call)",
        "Update StateAccess.hs to use MonadPresolution methods (1 lift call)",
        "Total lift $ calls in presolution modules under 10",
        "Typecheck passes",
        "All tests pass"
      ],
      "priority": 8,
      "passes": true,
      "notes": "Added registerNode and bindExpansionArgs to MonadPresolution. Added MonadPresolution instance for ReaderT. Reduced user-level lift calls from 6 to 4 (Copy.hs only). StateAccess.hs lift eliminated entirely."
    },
    {
      "id": "US-009",
      "title": "Introduce NodeMap newtype for type-node maps",
      "description": "As a developer, I want a NodeMap newtype so I can't accidentally use a gen-node-keyed map where a type-node-keyed map is expected.",
      "acceptanceCriteria": [
        "Create newtype NodeMap a = NodeMap (IntMap.IntMap a) in Constraint/Types.hs",
        "Add Functor, Foldable, Traversable, Eq, Show instances",
        "Add helper functions: lookupNode, insertNode, deleteNode, fromListNode, toListNode",
        "Export NodeMap and helpers from Constraint/Types.hs",
        "Typecheck passes"
      ],
      "priority": 9,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-010",
      "title": "Update cNodes field to use NodeMap",
      "description": "As a developer, I want the cNodes field in Constraint to use NodeMap for type safety.",
      "acceptanceCriteria": [
        "Change cNodes :: IntMap.IntMap TyNode to cNodes :: NodeMap TyNode in Constraint",
        "Update all direct IntMap operations on cNodes to use NodeMap helpers",
        "Update NodeAccess module to work with NodeMap",
        "Typecheck passes",
        "All tests pass"
      ],
      "priority": 10,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-011",
      "title": "Introduce GenNodeMap newtype for gen-node maps",
      "description": "As a developer, I want a GenNodeMap newtype so gen-node operations are type-safe.",
      "acceptanceCriteria": [
        "Create newtype GenNodeMap a = GenNodeMap (IntMap.IntMap a) in Constraint/Types.hs",
        "Add Functor, Foldable, Traversable, Eq, Show instances",
        "Add helper functions: lookupGen, insertGen, deleteGen, fromListGen, toListGen",
        "Update cGenNodes field to use GenNodeMap GenNode",
        "Typecheck passes",
        "All tests pass"
      ],
      "priority": 11,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-012",
      "title": "Introduce InteriorNodes and FrontierNodes newtypes",
      "description": "As a developer, I want distinct newtypes for interior and frontier node sets.",
      "acceptanceCriteria": [
        "Create newtype InteriorNodes = InteriorNodes IntSet.IntSet in Presolution/Base.hs",
        "Create newtype FrontierNodes = FrontierNodes IntSet.IntSet in Presolution/Base.hs",
        "Add Eq, Show, Semigroup, Monoid instances",
        "Add helpers: memberInterior, memberFrontier, toListInterior, toListFrontier, fromListInterior, fromListFrontier",
        "Typecheck passes"
      ],
      "priority": 12,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-013",
      "title": "Update EdgeTrace to use InteriorNodes newtype",
      "description": "As a developer, I want EdgeTrace to use the InteriorNodes newtype for type safety.",
      "acceptanceCriteria": [
        "Change etInterior :: IntSet.IntSet to etInterior :: InteriorNodes in EdgeTrace",
        "Update all code that accesses etInterior to use InteriorNodes helpers",
        "Update EdgeUnifyState.eusInteriorRoots and related fields",
        "Typecheck passes",
        "All tests pass"
      ],
      "priority": 13,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-014",
      "title": "Introduce CopyMapping newtype",
      "description": "As a developer, I want a CopyMapping newtype so copy maps are distinct from other IntMaps.",
      "acceptanceCriteria": [
        "Create newtype CopyMapping = CopyMapping (IntMap.IntMap NodeId) in Presolution/Base.hs",
        "Add Eq, Show, Semigroup, Monoid instances",
        "Add helpers: lookupCopy, insertCopy, copiedNodes, originalNodes",
        "Update CopyMap type alias and etCopyMap field to use CopyMapping",
        "Typecheck passes",
        "All tests pass"
      ],
      "priority": 14,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-015",
      "title": "Add error path tests for PresolutionError (part 1)",
      "description": "As a developer, I want tests that verify PresolutionError variants are correctly raised.",
      "acceptanceCriteria": [
        "Add test case for UnmatchableTypes error in PresolutionSpec.hs",
        "Add test case for UnresolvedExpVar error",
        "Add test case for ArityMismatch error",
        "Add test case for InstantiateOnNonForall error",
        "All new tests pass"
      ],
      "priority": 15,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-016",
      "title": "Add error path tests for PresolutionError (part 2)",
      "description": "As a developer, I want tests for remaining PresolutionError variants.",
      "acceptanceCriteria": [
        "Add test case for NodeLookupFailed error",
        "Add test case for OccursCheckPresolution error",
        "Add test case for BindingTreeError error",
        "Add test case for InternalError error",
        "All new tests pass"
      ],
      "priority": 16,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-017",
      "title": "Add Arbitrary instance for binding trees",
      "description": "As a developer, I want an Arbitrary instance for small binding trees to enable property-based testing.",
      "acceptanceCriteria": [
        "Add Arbitrary instance for small Constraint with valid binding tree in BindingSpec.hs",
        "Instance generates trees with 3-10 nodes",
        "Instance ensures parent-child relationships are valid",
        "Typecheck passes"
      ],
      "priority": 17,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-018",
      "title": "Add property-based tests for binding tree invariants",
      "description": "As a developer, I want QuickCheck properties that verify binding tree operations preserve invariants.",
      "acceptanceCriteria": [
        "Add property: canonicalization preserves tree structure",
        "Add property: validation detects all parent-child mismatches",
        "Add property: interior computation is idempotent",
        "All properties pass with 100 test cases each"
      ],
      "priority": 18,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-019",
      "title": "Add property-based tests for witness operations",
      "description": "As a developer, I want QuickCheck properties for witness normalization and canonicalization.",
      "acceptanceCriteria": [
        "Add Arbitrary instance for InstanceOp in PresolutionSpec.hs",
        "Add property: witness normalization is idempotent",
        "Add property: canonicalized witnesses have no redundant ops",
        "All properties pass with 100 test cases each"
      ],
      "priority": 19,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-020",
      "title": "Create PhiEnv record type for Phi.hs",
      "description": "As a developer, I want a PhiEnv record type to enable refactoring Phi.hs away from closure-based helpers.",
      "acceptanceCriteria": [
        "Create PhiEnv record in Elab/Phi.hs with fields: peResult, peCanonical, peCopyMap, peInvCopyMap, peGaParents, peTrace",
        "Create type alias PhiM = ReaderT PhiEnv (Either ElabError)",
        "Add helper functions: askResult, askCanonical, askCopyMap, askGaParents",
        "Typecheck passes"
      ],
      "priority": 20,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-021",
      "title": "Extract canonicalNode and remapSchemeInfo from Phi.hs closure",
      "description": "As a developer, I want canonicalNode and remapSchemeInfo extracted to module-level functions.",
      "acceptanceCriteria": [
        "Extract canonicalNode to module-level function taking SolveResult parameter",
        "Extract remapSchemeInfo to module-level function taking EdgeTrace and SchemeInfo",
        "Update phiFromEdgeWitnessWithTrace to use extracted functions",
        "Typecheck passes",
        "All tests pass"
      ],
      "priority": 21,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-022",
      "title": "Extract binder lookup helpers from Phi.hs closure",
      "description": "As a developer, I want binder lookup helpers extracted to use PhiEnv.",
      "acceptanceCriteria": [
        "Extract lookupBinderIndex to module-level function using PhiM monad",
        "Extract binderIndex to module-level function using PhiM monad",
        "Extract binderNameFor to module-level function using PhiM monad",
        "Typecheck passes",
        "All tests pass"
      ],
      "priority": 22,
      "passes": false,
      "notes": ""
    }
  ]
}
