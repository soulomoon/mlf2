Scope tracking redesign (paper-faithful binding edges + executable Raise)
========================================================================

Status
------
Implemented. The legacy var-level / level-tree scope model has been retired in
favor of the thesis's binding-edge story (see `papers/these-finale-english.txt`; `papers/xmlf.txt` for supplemental detail).

Goal
----
Match `papers/these-finale-english.txt`’s operational account (see also `papers/xmlf.txt`):

  - scope is represented directly in the expansion graph χe via binding edges
    (flex/rigid), and
  - `Raise(n)` is an *executable* graph transformation on χe, and is also
    recorded in the witness language Ω for Φ(e).

Current representation (repo)
-----------------------------
- Expansion graph: `Constraint` (`Constraint.cNodes` + edges).
- Binding tree: `Constraint.cBindParents :: BindParents` (child → (parent, flag)).
- Connectivity: constraints are rooted at a single gen node (created during
  constraint generation), so LCAs exist for well-formed graphs.
- Bounds/eliminations: `Constraint.cVarBounds` / `Constraint.cEliminatedVars`
  (`MLF.Constraint.VarStore`), keyed by canonical `NodeId`.

Executable `Raise(n)`
---------------------
- One-step raise: `MLF.Binding.GraphOps.applyRaiseStep` rewrites a binding edge
  `n ↦ parent` to `n ↦ parent(parent)` (preserving the edge flag).
- LCA harmonization: `MLF.Binding.Adjustment.harmonizeBindParentsWithTrace`
  repeatedly applies `applyRaiseStep` to raise nodes to a binding-tree LCA and
  returns the exact per-step `OpRaise` trace.

Where Raise is executed / recorded
----------------------------------
- Phase 2/5 (Normalize/Solve): before var-var unions, harmonize binding edges so
  scope is independent of union-find representative choice.
- Phase 4 (Presolution, χe): edge-local unification uses the same harmonization
  and records `OpRaise` in the per-edge Ω witness (filtered to the edge interior
  `I(r)` from `EdgeTrace.etInterior`).

Elaboration impact
------------------
- Binder enumeration for generalization uses the binding tree
  (`MLF.Binding.Tree.orderedBinders`) plus `MLF.Constraint.VarStore` bounds/eliminations.
- Φ translation uses the normalized Ω witness language; `OpRaise` is translated
  with paper-faithful placement (binder-raise first) in `MLF.Elab.Pipeline`.

References
----------
- `implementation_notes.md` (repo ↔ paper mapping)
- `plans/paper_general_raise_plan.txt` (Raise-specific status)
- `plans/merge_raise_merge_plan.txt` (end-to-end plan and remaining gaps)
