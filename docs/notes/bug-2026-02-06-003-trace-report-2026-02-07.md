# BUG-2026-02-06-003 Trace Report (2026-02-07)

## Scope

This report analyzes why the bounded-aliasing reproducer for `BUG-2026-02-06-003` still fails, despite existing Merge/RaiseMerge machinery.

Status note (2026-02-08): this document is a **trace snapshot of pre-refactor behavior**.  
The approved fix direction is staged raw/normalized frontend boundaries plus structural live-graph RaiseMerge gating; specific metadata-gating paths described here are expected to change when that plan is implemented.

Reproducer (from `/Volumes/src/mlf4/test/ElaborationSpec.hs`):

```haskell
ELet "c"
  (EAnn (ELam "x" (ELam "y" (EVar "x")))
        (STForall "a" Nothing
          (STForall "b" (Just (STVar "a"))
            (STArrow (STVar "a") (STArrow (STVar "b") (STVar "a"))))))
  (EAnn (EVar "c")
        (STForall "a" Nothing
          (STArrow (STVar "a") (STArrow (STVar "a") (STVar "a")))))
```

Expected: `∀a. a -> a -> a`  
Actual: `PipelineTypeCheckError (TCLetTypeMismatch ...)` in both unchecked and checked pipeline paths.

## Evidence Collected

### 1) Runtime failure is real in both pipeline variants

Direct script calling both:

- `runPipelineElab`
- `runPipelineElabChecked`

Both return the same `TCLetTypeMismatch` for the reproducer.

## 2) Presolution emits only `OpRaise` (no `OpMerge`/`OpRaiseMerge`) on the critical edge

Presolution dump (`computePresolution`) shows:

- edge `1` witness:
  - `steps=[StepOmega (OpRaise (NodeId 10))]`
  - `witness=[OpRaise (NodeId 10)]`
- edge `1` trace:
  - `binderArgs=[(NodeId 9, NodeId 31)]`
  - `interior={10,11}`
- edge `1` expansion:
  - `ExpInstantiate [NodeId 31]`

No Merge-like operation is present on the failing annotation edge.

## 3) `shouldRecordRaiseMerge` explicitly skips due to missing bound

Trace lines during edge-local unification include:

- `shouldRecordRaiseMerge: binder=NodeId 9 ext=NodeId 15 bound=None`

Code path:

- `runExpansionUnify` builds `binderBounds` from `VarStore.lookupVarBound` of source binders:
  - `/Volumes/src/mlf4/src/MLF/Constraint/Presolution/EdgeProcessing/Unify.hs:148`
- `shouldRecordRaiseMerge` checks `eusBinderBounds` and returns `False` on `Nothing`:
  - `/Volumes/src/mlf4/src/MLF/Constraint/Presolution/EdgeUnify.hs:573`
  - `/Volumes/src/mlf4/src/MLF/Constraint/Presolution/EdgeUnify.hs:580`
  - `/Volumes/src/mlf4/src/MLF/Constraint/Presolution/EdgeUnify.hs:590`

So the implementation is behaving as written: no bound metadata => no RaiseMerge emission.

## 4) Why bound metadata is absent for this path

Constraint inspection for the reproducer shows (normalized graph):

- `NodeId 9` (the source binder for edge `1`) is `TyVar ... bound=Nothing`

So `binderBounds` has no entry for this binder, leading directly to `bound=None`.

## 5) Frontend translation explains the disappearance of alias-bound binder shape

Current behavior at trace time (2026-02-07):

In coercion type internalization:

- `STForall var (Just (STVar alias))` branch rewrites via environment aliasing
  (`var -> aliasNode`) and recurses, instead of materializing a fresh bound binder node:
  - `/Volumes/src/mlf4/src/MLF/Frontend/ConstraintGen/Translate.hs:492`
  - `/Volumes/src/mlf4/src/MLF/Frontend/ConstraintGen/Translate.hs:494`
  - `/Volumes/src/mlf4/src/MLF/Frontend/ConstraintGen/Translate.hs:506`

This means `∀(b ⩾ a)` can be represented as substitution (`b := a`) before presolution sees an explicit `TyVar(b).tnBound = a` shape on that edge.

## 6) Consequence in elaboration

For this failing edge:

- Φ translation receives only `OpRaise` and yields `InstId` (`reifyInst phi edge=1 phi=InstId` in trace).
- `reifyInst` then enters fallback reconstruction for `ExpInstantiate`, using reified args and instantiation apps; this path introduces bottom-shaped arguments in this case.

Code path:

- fallback trigger and reconstruction:
  - `/Volumes/src/mlf4/src/MLF/Elab/Elaborate.hs:539`
  - `/Volumes/src/mlf4/src/MLF/Elab/Elaborate.hs:577`
- resulting mismatch:
  - annotated target `∀a. a -> a -> a` vs elaborated let type containing `⊥`.

## Causal Chain

1. `STForall (b ⩾ a)` alias case is inlined in frontend coercion translation.
2. The failing edge’s source binder is unbounded by the time presolution computes `binderBounds`.
3. `shouldRecordRaiseMerge` sees `bound=None` and suppresses RaiseMerge.
4. Edge witness has only `OpRaise`.
5. Φ for that edge is effectively identity; elaboration falls back to generic instantiation reconstruction.
6. Fallback introduces `⊥`-shaped argument structure, causing Phase-7 type mismatch.

## Answer to the key question

“Why does bounded alias elimination not trigger here?”

Because the branch that emits Merge/RaiseMerge requires explicit bounded-binder metadata at edge-unify time.  
On this reproducer, that metadata has already been erased/aliased away earlier (frontend coercion translation), so edge-unify correctly sees `bound=None` and does not emit RaiseMerge.

## Thesis-vs-Implementation mismatch (alias inlining vs RaiseMerge)

This bug is a semantic mismatch between where alias inlining happens and where RaiseMerge is decided:

1. Current implementation behavior:
   - Alias-shaped forall bounds are inlined/substituted during frontend coercion internalization (`STForall var (Just (STVar alias))`), before presolution witness construction.
   - As a consequence, the relevant source binder on the failing edge can reach edge-unify as effectively unbounded (`tnBound = Nothing`), so `binderBounds` has no entry and `shouldRecordRaiseMerge` returns `False`.

2. Thesis behavior:
   - The thesis’ RaiseMerge generation is driven by normalized propagation structure (`χe^p ⊑ χp`), not by preserving alias syntax at the witness-construction site.
   - In chapter 11 normalization, RaiseMerge is introduced when an interior node must leave the expansion and merge with exterior structure.
   - Alias-bound inlining is discussed later for syntactic iMLF/eMLF translation, and does not remove the structural need for RaiseMerge in propagation witnesses.

3. Practical implication for this bug:
   - We currently inline alias information too early for the edge-unify RaiseMerge gate we implemented.
   - The thesis can inline alias bounds and still emit RaiseMerge because RaiseMerge is structurally derived from propagation normalization, not from syntactic alias presence.

## 2026-02-08 locked direction (follow-up)

The fix direction is now locked as follows:

1. Raw parser output remains part of long-term stable public API.
2. Normalization diagnostics remain structural-only for now.
3. API split is explicit:
   - parser APIs may return raw syntax;
   - APIs that generate graphic constraints must take normalized syntax.
4. RaiseMerge gating direction:
   - remove dependency on precomputed/surviving alias-bound metadata;
   - compute gating from live structural graph facts (canonical bounds + binding-tree ancestry + edge interior).

This keeps the thesis-consistent behavior target while allowing alias inlining before graph generation.

Relevant thesis references (source of truth):
- Normalized propagation + RaiseMerge construction:
  - `/Volumes/src/mlf4/papers/these-finale-english.txt:11904`
  - `/Volumes/src/mlf4/papers/these-finale-english.txt:11985`
  - `/Volumes/src/mlf4/papers/these-finale-english.txt:11992`
- Translation rule where RaiseMerge remains an explicit witness operation:
  - `/Volumes/src/mlf4/papers/these-finale-english.txt:17838`
- Alias inlining discussion in syntactic iMLF/eMLF:
  - `/Volumes/src/mlf4/papers/these-finale-english.txt:18693`
  - `/Volumes/src/mlf4/papers/these-finale-english.txt:18736`
- Graphic presentation cannot directly express alias bounds:
  - `/Volumes/src/mlf4/papers/these-finale-english.txt:18738`

## Suggested next verification/fix checkpoints

1. Implement structural `shouldRecordRaiseMerge` gating from live graph state (remove `binderBounds` metadata dependency from edge-unify state).
2. Ensure the failing edge emits Merge-like witness ops (`OpMerge` or `OpRaise;OpMerge` => normalized `OpRaiseMerge`).
3. Complete staged frontend normalization boundary:
   - raw parser APIs return raw syntax;
   - graph-generating APIs accept normalized syntax only.
4. Keep rigid/non-translatable Φ invariants unchanged (existing strict tests must continue to pass).
5. Keep the updated regression in `/Volumes/src/mlf4/test/ElaborationSpec.hs` red-to-green:
   - `bounded aliasing (b ⩾ a) elaborates as ∀a. a -> a -> a (Merge/RaiseMerge path)`
6. After implementing the approved plan, refresh this report with post-change traces and remove/replace references to `binderBounds`/`eusBinderBounds` if those paths no longer exist.
