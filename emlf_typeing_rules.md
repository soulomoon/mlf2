# eMLF typing rules (from `papers/these-finale-english.txt`)

This note extracts the **eMLF** (explicit MLF) typing rules as they are presented *in this thesis* via **typing constraints**, plus the definition of **type annotations** via coercion functions.

Relevant thesis locations:

- Expression syntax (unannotated + annotated): §1.6
- Typing constraints (constraint-generation rules): §9.4 (Figure 9.4.1)
- Constraint semantics used to interpret “typable” and “type of an expression”: §10.3–§10.5 (Definitions 10.3.1–10.4.2; §10.5.2)
- Type annotations (as coercion functions): §12.3.2 (Figure 12.3.1)

## 0. What “eMLF” means here (§10.5.2)

The thesis distinguishes three “flavours” of MLF by the **instance relation** used when interpreting constraints:

- **gMLF**: instance relation `⊑`
- **eMLF**: instance relation `⊑≈`
- **iMLF**: instance relation `⊑−`

The constraint generation rules are the same; **only the instance relation used in the “solved edge / presolution / solution” definitions changes**.

In the rest of this note, “eMLF” means: interpret the generic constraint semantics of §10 using `⊏ := ⊑≈`.

### 0.1 Instance modulo similarity `⊑≈` (definition, §5.3.4)

The thesis defines **instance modulo similarity** `⊑≈` by first isolating the “reversible” part of instance on **monomorphic** nodes:

- `⊑m`, `⊑r`, `⊑w`: merging / raising / weakening restricted to *monomorphic* nodes (Definition 5.3.12)
- `⊑rmw`: the subrelation of `⊑` generated by those monomorphic operations (called “reversible instance”)
- `≈`: similarity, defined as the equivalence relation `(⊑rmw ∪ ⊒rmw )*`
- `⊑≈`: instance modulo similarity, defined as `(⊑ ∪ ≈)*`

## 1. Expression syntax (§1.6)

The unannotated core language:

```
a ::= x
    | λ(x) a
    | a a
    | let x = a in a
```

The thesis also considers annotated expressions (type annotations are defined precisely in §12.3.2):

```
a′ ::= x
     | λ(x) a′
     | λ(x : σ) a′
     | a′ a′
     | let x = a′ in a′
     | (a′ : σ)
```

## 2. Type annotations via coercion functions (§12.3.2)

The thesis models type annotations *without adding special typing rules* by extending the term language with a denumerable family of **coercion functions**.

### 2.1 Syntactic sugar for annotations (§12.3.2)

For any closed annotation “type” (written `τ` in the thesis text), there is a constant `cτ`, and:

```
(a : τ)        ≜  cτ a

λ(x : τ) a     ≜  λ(x) let x = (x : τ) in a
```

So annotations are treated as ordinary applications/lets in the core language, with the annotation effect carried by `cτ`.

### 2.2 Generalized annotations (§12.3.2.1–§12.3.2.2)

The thesis generalizes annotations beyond “a closed type τ”, to annotations that contain both universal and existential parts (represented graphically by a pseudo-type `κ` in Figure 12.3.1).

To each annotation `κ` it associates a coercion function `cκ` whose type (Figure 12.3.1) has the following key properties:

- The coercion is an arrow between **two copies** of a type graph `τ` (the “shape” demanded by the annotation).
- The **domain** copy is **rigidly bound**: its polymorphism is *requested* and cannot be weakened by instantiation; the argument must match `τ`.
- The **codomain** copy is **flexibly bound**: its polymorphism is *provided* and can be instantiated.
- Nodes corresponding to the **existential** part of the annotation are **shared** between the domain and codomain copies, so they are instantiated consistently on both sides.

## 3. Constraint-generation “typing rules” (§9.4, Figure 9.4.1)

Typing is defined by translating expressions to **typing constraints** (Definition 9.4.1).

The thesis uses **expression nodes** as meta-notation for “the constraint generated from this subexpression”, with incoming edges from the typing environment constraining free variables.

The primitive forms are translated as follows (Figure 9.4.1 + explanation in §9.4):

### 3.1 Variables

`x` is typed as the universal type scheme `∀(α) α`:

- Graphically: a gen node `g` introducing one scheme whose body is a bottom node bound on `g`.
- The bottom node is constrained by the (unique) environment edge labelled `x`.
- Side condition: if the environment does not provide such an edge, the resulting constraint is not closed (hence untypable).

### 3.2 Let

`let x = a1 in a2` is typed as `a2`, with the additional constraint that:

- **all occurrences of `x` in `a2` must be instances of the type scheme computed for `a1`.**

(I.e. the let-bound value’s scheme is used via instantiation edges at each occurrence.)

### 3.3 Abstraction

`λ(x) a` is typed as the type scheme:

```
∀ (α ⩾ ⊥) ∀ (β ⩾ ⊥) α → β
```

with constraints that:

- `β` (the codomain) is required to be an **instance** of the type of `a` (the body).
- all occurrences of `x` inside `a` must **unify** with `α` (the domain).

### 3.4 Application

`a1 a2` is typed by introducing an existential arrow type and returning its codomain:

- the **domain** of the arrow is constrained to be an **instance** of the type of `a2`;
- the **arrow type as a whole** is constrained to be an **instance** of the type of `a1`.

## 4. Interpreting the constraints as eMLF typing (§10.3–§10.4)

The constraint semantics of §10 is parameterized by an instance relation `⊏`. For **eMLF**, set `⊏ := ⊑≈`.

### 4.1 Solved edges (§10.3)

- A unification edge `n1  n2` is solved iff `n1 = n2`. (Definition 10.3.1)
- For an instantiation edge `e`, define its **propagation** `χe` by expanding the corresponding type scheme at the target’s binder and unifying the constrained node with the root of the expansion. (Definition 10.3.2)
- The instantiation edge `e` is **eMLF-solved** iff `χe ⊑≈ χ`. (Definition 10.3.4 instantiated with `⊏ := ⊑≈`)

### 4.2 Presolutions and solutions (§10.4)

- An **eMLF presolution** of a constraint `χ` is an instance `χp` such that `χ ⊑≈ χp` and all edges in `χp` are solved (unification edges solved; instantiation edges eMLF-solved). (Definition 10.4.1 instantiated to `⊑≈`)
- An **eMLF solution** of `χ` is a type `τ` witnessed by some eMLF presolution `χp`, defined by adding one more instantiation edge at the root as in Figure 10.4.2 and requiring that edge to be eMLF-solved. (Definition 10.4.2 instantiated to `⊑≈`)

### 4.3 “Typing in eMLF” (derived)

Given an (annotated) expression `a′`:

1. Desugar annotations into coercion functions as in §2 (so the term is in the core language).
2. Generate its typing constraint `χ` using the rules of Figure 9.4.1.
3. The possible **eMLF types** of the expression are exactly the **eMLF solutions** of `χ` (Definition 10.4.2 with `⊏ := ⊑≈`).
